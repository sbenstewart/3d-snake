/****************************************************************************
 * createVRScene.js
 *
 * Used to create an empty babylon scene with the default VR experience.
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    /**
     * createVRSceme ( babylon, engine )
     *
     * Returns a Babylon scene with the default VR experience.     
     */
    babylonProject.createVRScene = function ( babylon, engine )
    {
        let scene = new babylon.Scene ( engine );

        scene.createDefaultEnvironment ();
        
        let vrHelper = scene.createDefaultVRExperience ();

        let returnValue = 
        {
            scene    : scene,
            vrHelper : vrHelper
        };

        return returnValue;
    };
} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * gameLoop.js
 *
 * This is the main game loop that is used to update objects and render
 * the scene.
 *
 * A finite state machine is used to switch between logical scenarios
 * such as the main menu or gameplay.
 *
 * The states are defined as functions that are to be executed each tick.
 *
 * The next function to be called to update the game's state is
 * stored as a function pointer in:
 *     
 *     babylonProject.nextUpdate;
 *
 * The game loop will call nextUpdate () and save its return as nextUpdate().
 *
 * The state functions are expected to wrap their data and execution in
 * an 'arrow operator' function pointer with any data they need and
 * return it so that calling nextUpdate () again will advance the state.
 *
 * The './pageLoaded.js' page loaded function sets the initial state to
 * 'babylonProject.StartState'.  This state can be found in the root
 * of the 'game_logic' directory and is a starting point for any game
 * using the base game as its template.
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    /**
     * babylonProject.nextUpdate
     *
     * This is expected to be a function pointer that can be called with
     * no paramters in order to advance the execution of the game by one
     * tick.
     *
     * The function should return a function pointer that can be called
     * with no paramters to execute the next tick.
     */
    babylonProject.nextUpdate = () => {};

    /**
     * babylonProject.gameLoop
     *
     * Calls babylonProject.nextUpdate () and saves its return in
     * babylonProject.nextUpdate.
     *
     * This should advance the game by one logic tick and save a function
     * pointer that can be called to execute the next tick.
     */
    babylonProject.gameLoop = function ()
    {
        //update state and store return value as next update
        babylonProject.nextUpdate = babylonProject.nextUpdate (); 
    }

} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * gui.js
 *
 * Handles the creation of commonly used GUI components.
 ***************************************************************************/

( function ( babylonProject, undefined )
{

    babylonProject.createButtonPlane = 
        function ( name, planeOptions, buttonOptions, scene, babylon )
    {
        if ( name == undefined )
        {
            throw ( "name parameter is undefined" );
        }

        if ( planeOptions == undefined )
        {
            throw ( "planeOptions parameter is undefined" );
        }

        if ( buttonOptions == undefined )
        {
            throw ( "buttonOptions parameter is undefined" );
        }

        if ( scene == undefined )
        {
            throw ( "scene parameter is undefined" );
        }

        if ( babylon == undefined )
        {
            throw ( "babylon parameter is undefined" );
        }

        let plane = babylon.MeshBuilder.CreatePlane (
            name+"ButtonPlane", planeOptions, scene );

        let advancedTexture = 
            babylon.GUI.AdvancedDynamicTexture.CreateForMesh ( plane );

        let button = 
            babylon.GUI.Button.CreateSimpleButton ( 
                    name+"Button", buttonOptions.buttonText );

        button.width = 1;
        button.height = 0.4;
        button.color = "white";
        button.fontSize = 50;
        button.background = "green";

        button.onPointerUpObservable.add ( buttonOptions.buttonCall );

        advancedTexture.addControl ( button );

        let retVal =
        {
            buttonPlane   : plane,
            button        : button,
            buttonTexture : advancedTexture
        };

        return retVal;
    };

} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * jQueryDomFunctions.js
 * 
 * Functions where the game interacts with the DOM are defined here.
 *
 * This function is outside the coverage of unit testing as it was 
 * awkward to mock jQuery and the DOM.
 *
 * Where possible it simply  passes DOM objects to a function within the
 * scope of tests.
 ***************************************************************************/

(function( babylonProject, $,  undefined )
{
    //Called when all HTML/DOM objects have been loaded.
    $(document).ready(function() 
    {
        babylonProject.pageLoaded ( document, BABYLON );
    });

    //Dynamically resizes the canvas as the browser window changes.
    // The babylon game engine is no longer available as a global var
    // if the resize function is needed in future it will have to be 
    // rewritten so that the engine instance is passed to it from the
    // pageloaded.js script
//    $(window).on("resize load", function()
//    {
//        if ( babylonProject.engine )
//        {
//            babylonProject.engine.resize();
//        }
//    });

} ( window.babylonProject = window.babylonProject || {},
    jQuery));

/****************************************************************************
 * pageLoaded.js
 *
 * The page loaded function is called by the jQueryDomFunctions.js 
 * module when the HTML Document is ready.
 *
 * This is the entry point into the game logic.  The game should be 
 * initialized and the first state of the finite state machine defined
 * in game_state/ should be loaded for the game loop to execute.
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    /**
     * pageLoaded ( documentRef, babylonRef )
     *
     * The first game logic function that is called when the
     * HTML page is ready.
     *
     * Sets the babylonProject.nextUpdate function pointer to be
     * babylonProject.startState
     *
     * Parameters:
     *  - documentRef: The HTML DOM object 'document'
     *  - babylonRef : A reference to the Babylon object
     */
    babylonProject.pageLoaded = function ( documentRef, babylonRef )
    {
        let canvas = documentRef.querySelector( "#renderCanvas" );

        let gameData = 
        {
            engine : babylonProject
                        .createBabylonEngine ( babylonRef, canvas )
        }

        //set the next update to be the startState function
        babylonProject.nextUpdate = () => 
                    babylonProject.startState( babylonRef, gameData );

        gameData.engine.runRenderLoop ( babylonProject.gameLoop );
    };

    /**
     * createBabylonEngine ( babylonRef, canvas )
     *
     * The call to the constructor of the Babylon engine has been 
     * encapsulated within this factory method to enable mocking
     * of the engine object during testing.
     */
    babylonProject.createBabylonEngine = function ( babylonRef, canvas )
    {
        //check if canvas is undefined as it would create a silent error
        //if the engine was initialized without a valid canvas

        if ( canvas == null )
        {
            throw "Canvas is undefined.";
        }

        return new babylonRef.Engine ( canvas, true );
    };
} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * config.js
 *
 * Provides access to configuration data.  Things such as object sizes,
 * colours and positions can be defined here so they can be adjusted 
 * during development.
 ***************************************************************************/

( function ( babylonProject, undefined )
{

    babylonProject.config = 
    {
        snakeMoveInitialInterval : 1200,

        //directions the snake turn buttons should move the snake
        
        dirUp    : { x :  1, y :  0 },
        dirDown  : { x : -1, y :  0 },
        dirLeft  : { x :  0, y :  1 },
        dirRight : { x :  0, y : -1 },

        isValidDirection : function ( d )
        {
            if ( d == this.dirUp   || d == this.dirDown || 
                 d == this.dirLeft || d == this.dirRight )
            {
                return true;
            }
            else
            {
                return false;
            }
        },

        //position of the direction button planes
        
        upPos    : { x :    0, y : 1.25, z : 1 },
        downPos  : { x :    0, y : 0.75, z : 1 },
        rightPos : { x :  0.5, y :    1, z : 1 },
        leftPos  : { x : -0.5, y :    1, z : 1 },

        turnControlPlaneSize :  0.3
    };

} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * gameplayState.js
 *
 * Checks if the snake has moved and updates the grid squares if so.
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    babylonProject.GameplayStateData = function ( babylon, scene )
    {
        if ( babylon == undefined )
        {
            throw new Error ( "babylon is undefined." );
        }

        if ( scene == undefined )
        {
            throw new Error ( "scene is undefined." );
        }

        //create snake
        this.snakeParts = babylonProject.snake
            .createSnake ( babylonProject.config.dirLeft, 3);

        //snake move timer and interval

        this.snakeMoveInterval =
            babylonProject.config.snakeMoveInitialInterval;

        this.snakeMoveTimer =
            babylonProject.config.snakeMoveInitialInterval;

        //apple position

        this.applePos = { x : 2, y : 1 };

        //current direction

        this.currentDir = babylonProject.config.dirLeft;

        //turn input controls

        this.turnInputControls = 
            new TurnInputControls ( babylon, scene, this );

    }

    babylonProject.gameplayState = 
        function ( babylon, gameData, stateData )
    {

        if ( babylon == undefined )
        {
            throw new Error ( "babylon is undefined." );
        }

        if ( gameData == undefined )
        {
            throw new Error ( "gameData is undefined." );
        }

        if ( stateData == undefined )
        {
            throw new Error ( "stateData is undefined." );
        }

        let config = window.babylonProject.config;

        //enable arrow buttons that are perpindicular to currentDir

        let setButtonEnabled = ( controlName, enabled ) => 
        {
            stateData.turnInputControls [ controlName ].buttonPlane
                .isEnabled ( enabled  );

            stateData.turnInputControls [ controlName ].button
                .isEnabled = enabled;

            stateData.turnInputControls [ controlName ].button
                .isVisible = enabled;

        }

        let vertical = ( stateData.currentDir == config.dirUp ||
                         stateData.currentDir == config.dirDown );

        setButtonEnabled ( "upControl",   !vertical );
        setButtonEnabled ( "downControl", !vertical );
        setButtonEnabled ( "rightControl", vertical );
        setButtonEnabled ( "leftControl",  vertical );

        //check if move timer has elapsed and move if so

        stateData.snakeMoveTimer -= gameData.engine.getDeltaTime ();

        if ( stateData.snakeMoveTimer <= 0 )
        {
            stateData.snakeMoveTimer = stateData.snakeMoveInterval;

            stateData.snakeParts = 
                window.babylonProject.snake.moveSnake (
                        stateData.currentDir, 
                        stateData.snakeParts, 
                        gameData.wrapTorusCoord );

            stateData.applePos = 
            {
                x : stateData.applePos.x + stateData.currentDir.x,
                y : stateData.applePos.y + stateData.currentDir.y
            };

            stateData.applePos = 
                gameData.wrapTorusCoord ( stateData.applePos );

            window.babylonProject.updateTorusMeshes ( 
                      stateData.snakeParts,
                      stateData.applePos,
                      gameData.torusMeshes,
                      gameData.torusCoordToMeshIdx,
                      gameData.snakeMat,
                      gameData.appleMat  
                      );
        } 

        //render the scene and return next state

        gameData.scene.render ();

        return () => babylonProject
            .gameplayState ( babylon, gameData, stateData );
    }

    /************************************************************************
     * Input Controls
     ***********************************************************************/

    let TurnInputControls = function ( babylon, scene, stateData )
    {
        if ( babylon == undefined )
        {
            throw new Error ( "babylon is undefined." );
        }

        if ( scene == undefined )
        {
            throw new Error ( "scene is undefined." );
        }

        if ( stateData == undefined )
        {
            throw new Error ( "stateData is undefined." );
        }

        let config = babylonProject.config; 

        let buttonData = [
            {
                name        : "up",
                text        : "U",
                dir         : config.dirUp,
                pos         : config.upPos,
                controlName : "upControl"
            },

            {
                name        : "down",
                text        : "D",
                dir         : config.dirDown,
                pos         : config.downPos,
                controlName : "downControl"
            },

            {
                name        : "left",
                text        : "L",
                dir         : config.dirLeft,
                pos         : config.leftPos,
                controlName : "leftControl"
            },

            {
                name        : "right",
                text        : "R",
                dir         : config.dirRight,
                pos         : config.rightPos,
                controlName : "rightControl"
            }
        ];

        let turnControlCallback = function ( stateData, newDir )
        {
            stateData.currentDir = 
                babylonProject.snake
                    .turnSnake ( newDir, stateData.currentDir );
        };

        //Create the data in a loop.  Note that the 'this' parameter is 
        //passed to bind the data to this object as its constructed

        buttonData.forEach ( function ( data )
        {
            this [ data.controlName ] = 
                babylonProject.createButtonPlane (

                    data.name,

                    //plane options
                    {
                        size  : config.turnControlPlaneSize
                    },
                    //button options
                    {
                        buttonText : data.text,
                        buttonCall : 
                            () => turnControlCallback ( stateData, data.dir ) 
                    },
                    scene,
                    babylon

            );
            

            this [ data.controlName ].buttonPlane.position = data.pos;

        }, this);
        
    };


} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * snake.js
 *
 * Defines functions used to manipulate the snake data structure.
 *
 * Snakes are defined as a list of coordinate positions.
 *
 * The coorindates are offsets from the head of the snake so:
 *   - Snake head is always   :  { x : 0, y : 0 }
 *   - Adjacent part would be :  { x : 1, y : 0 }
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    //empty object is used to contain other snake functions in a namespace
    babylonProject.snake = {};

    /**
     * babylonProject.snake.turnAllowed ( newDir, currentDir )
     *
     * Returns true if the snake is allowed to turn towards newDir
     * from currentDir.
     *
     * Only perpindicular movement is allowed.
     */
    babylonProject.snake.turnAllowed = function ( newDir, currentDir )
    {
        let config = window.babylonProject.config;

        if ( !config.isValidDirection ( newDir ) )
        {
            throw ( "newDir is not valid direction" );
        }

        if ( !config.isValidDirection ( currentDir ) )
        {
            throw ( "currentDir is not valid direction" );
        }

        let u = config.dirUp;
        let d = config.dirDown;
        let l = config.dirLeft;
        let r = config.dirRight;

        //check perpindicular for up or down
        let vertical =
            ( newDir == u     || newDir == d ) && 
            ( currentDir == l || currentDir == r );
        
        //check perpindicular for left or right
        let horizontal =
            ( newDir == r     || newDir == l ) && 
            ( currentDir == u || currentDir == d );

        return ( vertical || horizontal );
        
    };

    babylonProject.snake.moveSnake = function ( dir, snakeParts, wrapFunc )
    {
        if ( !babylonProject.config.isValidDirection ( dir ) )
        {
            throw ( "dir is not valid direction" );
        }
        
        let newSnake = snakeParts.map ( function ( val, idx, arr )
        {
            let retVal = { x : 0, y : 0 };

            if ( idx != 0 )
            {
                retVal.x = snakeParts [ idx - 1 ].x + dir.x;
                retVal.y = snakeParts [ idx - 1 ].y + dir.y;

                retVal = wrapFunc ( retVal );
            }

            return retVal;
        });

        return newSnake;
    }

    /**
     * bylonProject.snake.turnSnake ( newDir, currentDir )
     *
     * Checks if the snake is allowed to turn towards newDir from
     * the currentDir.  I.e. the directions are perpendicular.
     *
     * If the turn is allowed then newDir will be returned.
     *
     * Otherwise currentDir will be returned.
     */
    babylonProject.snake.turnSnake = function ( newDir, currentDir )
    {
        if ( babylonProject.snake.turnAllowed ( newDir, currentDir ) )
        {
            return newDir;
        } 
        else
        {
            return currentDir;
        }   
    };

    /**
     * Adds a new head to the snake and then moves it in the desired 
     * direction.
     *
     * Note that when the snake eats an apple this function should be 
     * called after the normal move delay instead of using the normal
     * move function.
     *
     * moveSnake is called as part of this function so that the snake 
     * doesn't end up with multiple sections occupying the same position.
     */
    babylonProject.snake.growSnake = function ( dir, snakeParts, wrapFunc )
    {
        let newSnakeParts = [ { x : 0, y : 0 } ].concat ( snakeParts );

        return babylonProject.snake.moveSnake 
            ( dir, newSnakeParts, wrapFunc );
    }; 

    /**
     * babylonProject.snake.createSnake ( dir, length )
     *
     * Creates a snake with the number of parts specified by the length
     * parameter.
     *
     * The snake is created using the growSnake function.
     *
     * The length is NOT checked against the size of the grid so attempts
     * to create a snake longer than the grid can hold will result in
     * terrible things.
     *
     * The head will be { x:0, y:0 } and other items will be offset
     * according to dir
     */
    babylonProject.snake.createSnake = function ( dir, length )
    {
        if ( length <= 0 )
        {
            throw ( "length must be > 0" ); 
        }

        let snakeParts = [];

        //move snake expects a function to use to wrap the coordinates
        //this dummy function will return the same input
        let wrapFunc = ( snakeParts ) => { return snakeParts; }

        for ( let i = 0; i < length; i++ )
        {
            snakeParts = babylonProject.snake.growSnake (
                    dir, snakeParts, wrapFunc );
        }

        return snakeParts;
    };

} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * startState.js
 * 
 * The ./base_game/ functions define a gameLoop that expects a function
 * with no paramters each tick.
 *
 * On page load babylonProject.startState ( babylon, gameData ) is set to be
 * called.
 *
 * When called it is expected to update the game state and return a 
 * function pointer that can be called with no parameters on the next
 * update.
 *
 * By default the startState will expect the gameData to have a property
 * 'gameData.engine' that contains an instance of the BabylonJS engine 
 * created by the page loaded function.
 *
 * if gameData.scene has not beed defined the function will create it 
 * and the game objects needed.  Any extra data needed for the game will
 * be stored in gameData.
 *
 * The function will update the state and then use the javascript 
 * arrow notation to return a function pointer that can be called with no
 * paramters for the next update tick of the game loop.
 *      
 * See ./base_game/gameLoop.js for more information.
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    /**
     * babylonProject.startState ( babylon, gameData)
     *
     * Updates the game's state and returns a function that can be 
     * called with no paramters for the next update.
     */
    babylonProject.startState = function ( babylon, gameData )
    {
        if ( gameData == undefined )
        {
            throw new Error ( "GameData is undefined." );
        }

        if ( gameData.engine == undefined )
        {
            throw new Error ( "Engine is undefined." );
        }

        if ( babylon == undefined )
        {
            throw new Error ( "Babylon is undefined." );
        }

        //private procedure used to initialize all the game objects
        initializeGameData ( babylon, gameData );

        //create the data for the next state

        let stateData = 
            new babylonProject.GameplayStateData ( babylon, gameData.scene );

        return () => 
            babylonProject.gameplayState ( babylon, gameData, stateData );
    }; 

    /************************************************************************
     * PRIVATE FUNCTIONS
     ***********************************************************************/

    let initializeGameData = function ( babylon, gameData )
    {
        createScene ( babylon, gameData );

        createMaterials ( babylon, gameData );

        createTorus ( babylon, gameData );

        createTorusMeshes ( babylon, gameData ); 

        createTorusIndexFunctions ( gameData );

    }

    let createScene = function ( babylon, gameData )
    {

        //create the VR scene using base_game/ createVRScene function
        let vrSceneData =
            babylonProject.createVRScene ( babylon, gameData.engine );
 
        gameData.scene = vrSceneData.scene;

        gameData.vrHelper = vrSceneData.vrHelper;

        gameData.vrHelper.enableInteractions ();

        //create light
        gameData.light = new babylon.DirectionalLight (
                "light", 
                new babylon.Vector3 ( 0, 0.5, 1.0 ), 
                gameData.scene  );
 
        gameData.light.position = new babylon.Vector3 ( 0, 5, 2 );

    }

    let createMaterials = function ( babylon, gameData )
    {

       gameData.torusMat = 
           new babylon.StandardMaterial ( "torusMat", gameData.scene );

       gameData.snakeMat = 
           new babylon.StandardMaterial ( "snakeMat", gameData.scene );

       gameData.snakeMat.diffuseColor =
           new babylon.Color3 ( 0, 255, 0 );

       gameData.appleMat = 
           new babylon.StandardMaterial ( "appleMat", gameData.scene );

       gameData.appleMat.diffuseColor =
           new babylon.Color3 ( 255, 0, 0 );

    }

    let createTorus = function ( babylon, gameData )
    {
        //Create torus
        torus_options = 
        {
            diameter : 3,
            thickness : 0.75,
            tessellation : 16 
        }
 
        gameData.torus = babylon.MeshBuilder.CreateTorus (
                "torus", torus_options, gameData.scene );
 
        gameData.torus.position = new babylon.Vector3 ( 0, 1, 0 );
 
        //set torus material and make wireframe
        gameData.torus.material = gameData.torusMat;
 
        gameData.torus.material.wireframe = true;
 
    }

    let createTorusMeshes = function ( babylon, gameData )
    {
        //create a mesh for every unique vertex of the torus
        //
        //There will be duplicated vertex positions for each row
        //and column of the grid.
        //
        //To avoid duplicate torus meshes the last element in each row
        //and the last column of the vertex data will be skipped
        //
        //A torus with tesselation of n will correspond to a snake
        //grid with n-1 rows and columns
        
        let torusVD = gameData.torus
            .getVerticesData ( babylon.VertexBuffer.PositionKind ) ;
 
        gameData.torusMeshes = [];
 
        //loop through vertex position buffer 3 spaces at a time 
        //in order to read position data as float3[]
        //
        //The loop termination condition stops before the last row
        //of data.

        let vertexGridElems = torusVD.length / 3;

        let vertexGridSize = Math.sqrt ( vertexGridElems );

        let snakeGridSize = vertexGridSize - 1;

        let snakeGridElems = snakeGridSize * snakeGridSize;

        //keep track of spawn count for assigning ID
        let spawnCount = 0;

        torusVD.forEach ( function ( value, idx, array )
        {
            //vector3s are stored as 3 list elements so only process
            //every third item
            
            if ( idx % 3 != 0 )
            {
                return;
            }

            //store the vector idx for readability

            let vectorIdx = idx/3;

            //skip the final row of vertex grid

            if ( vectorIdx >= vertexGridElems - vertexGridSize )
            {
                return;
            }

            //skip the final element of each row of the vertex grid

            if ( ( vectorIdx + 1 ) % vertexGridSize == 0 )
            {
                return;
            }
            
            //use string formatter to make unique name
            let meshName = `TorusMesh${ spawnCount++ }`; 
            
            let mesh = babylon.MeshBuilder.CreateSphere (
                    meshName,
                    { diameter : 0.1 },
                    gameData.scene );
 
            let vertexPos = babylon.Vector3.FromArray ( torusVD, idx );
 
            mesh.position = vertexPos.add (
                   gameData.torus.position,  );
 
            gameData.torusMeshes.push ( mesh );

        });
    }

    /**
     * This sub-routine stores function calls to the index mapping
     * functions so that they can be called elsewhere in the system
     * without having to pass things like the grid size or other
     * data that doesn't change throughout the game.
     */ 
    let createTorusIndexFunctions = function ( gameData )
    {
        let width = Math.sqrt ( gameData.torusMeshes.length );

        gameData.meshIdxToTorusCoord = 
            ( i ) => window.babylonProject.listIdxToCoord 
                         ( 
                            i, width, gameData.torusMeshes.length
                         );

        gameData.torusCoordToMeshIdx  = 
            ( coord ) => window.babylonProject.coordToListIdx  
                         ( 
                            coord, width, gameData.torusMeshes.length
                         );

        gameData.wrapTorusCoord  = 
            ( coord ) => window.babylonProject.wrapCoordinate  
                         ( 
                            coord, width, width
                         );

    }
} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * torusCoordinates.js
 *
 * Provides a function that maps a set of 1 dimensional list indicies
 * to a two dimensional { x , y } coordinate tuple.
 *
 * The tests for the module have some examples of the functions with
 * various shapes of array
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    //This function allows negative numbers to be wrapped into positive
    //number.  Javascript's modulo returns a negative result for negative
    //values, which is not what is wanted to wrap coordinates.
    let wrap = ( x, n ) => ( x % n + n ) % n;

    babylonProject.listIdxToCoord = function ( idx, width, length )
    {
        if ( idx < 0 || idx == undefined )
        {
            throw ( "idx must be >= 0" );
        }

        if ( idx > length - 1)
        {
            throw ( "idx out of bounds of the list" );
        }

        if ( width < 1 || width == undefined )
        {
            throw ( "width must be >= 0" );
        }

        if ( length % width != 0 )
        {
            throw ( "width should divide length with no remainder." );
        }

        let coord = 
        { 
            x : idx % width,
            y : Math.floor ( idx/width )
        }

        return coord;
    }
    
    /**
     * coordToListIdx
     *
     * Maps a 2 dimensional coordinate to an index of a one dimensional
     * list.
     *
     * Coordinates outside the range of the 2D space will be wrapped
     * as though the space is a torus.
     *
     * Params:
     *  - coord  : The two dimensional { x, y } coordinate tuple
     *  - width  : The width of the 2D space
     *  - length : The number of elements in a 1D list containing all the 
     *             coordinates
     */
    babylonProject.coordToListIdx = function ( coord, width, length )
    {
        if ( width < 1 || width == undefined )
        {
            throw ( "width must be > 0" );
        }

        if ( length < 1 )
        {
            throw ( "list length must be > 0" );
        }

        if ( length % width != 0 )
        {
            throw ( "width should divide length with no remainder." );
        }

        let height = length / width;

        return width * wrap ( coord.y, height ) + wrap ( coord.x, width );
    };

    /**
     * wrapCoordinate
     *
     * Wraps the x and y of the coordinate parameter to  fit within
     * a torus shaped grid with the width and length provided.
     */
    babylonProject.wrapCoordinate = function ( coord, width, height )
    {
       let wrappedCoord = 
       {
           x : wrap ( coord.x, width ),
           y : wrap ( coord.y, height )
       };

       return wrappedCoord;
    }

} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * updateTorusMeshes.js
 *
 * Defines a function that updates a list of meshes in order to represent
 * the current state of the snake body.
 *
 * The headIndex parameter specifies which mesh should represent the head
 * of the snake.  The position of the other body parts will be calculated
 * relevant to this.
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    /**
     * babylonProject.updateTorusMeshes
     * 
     * Given a list of the meshes that appear at each vertex of the 
     * torus this function will toggle isVisible on each according
     * to the current position of the snake.
     */  
    babylonProject.updateTorusMeshes = 
        function ( snakeParts, applePos, torusMeshes, torusCoordToMeshIdx,
                   snakeMat, appleMat  )
    {

        if ( snakeParts == undefined )
        {
            throw ( "snakeParts parameter is undefined" );
        }
        
        if ( applePos == undefined )
        {
            throw ( "applePos parameter is undefined" );
        }
        
        if ( torusMeshes == undefined )
        {
            throw ( "torusMeshes parameter is undefined" );
        }
        
        if ( torusCoordToMeshIdx == undefined )
        {
            throw ( "torusCoordToMeshIdx parameter is undefined" );
        }

        if ( snakeMat == undefined )
        {
            throw ( "snakeMat parameter is undefined" );
        }

        if ( appleMat == undefined )
        {
            throw ( "appleMat parameter is undefined" );
        }

        //set all torusMeshes to be invisble
        torusMeshes.forEach ( 
        function ( torusMesh )
        {
            torusMesh.isVisible = false;
        });

        //set the snake torusMeshes to be visible
        snakeParts.forEach (
        function ( s )
        {
            let meshIdx = torusCoordToMeshIdx ( s );

            torusMeshes [ meshIdx ].isVisible = true;

            torusMeshes [ meshIdx ].material = snakeMat;

        });

        //set the apple mesh to be visible

        let appleIdx = torusCoordToMeshIdx ( applePos );

        torusMeshes [ appleIdx ].isVisible = true;

        torusMeshes [ appleIdx ].material = appleMat;

    }


} ( window.babylonProject = window.babylonProject || {} ));
